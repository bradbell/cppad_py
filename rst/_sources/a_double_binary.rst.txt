lines 330-439 of file: lib/cplusplus/a_double.cpp

{xrst_begin a_double_binary}
{xrst_spell
   radd
   rdiv
   rmul
   rsub
}

a_double Binary Operators with an AD Result
###########################################


Syntax
******

Python
======
| *az* = *ax* *op* *ay*
| *az* = *ax* *op* *y*
| *az* = *x* *op* *ay*

C++
===
| *az* = *ax* *op* *ay*
| *az* = *ax* *op* *y*
| *az* = *fun* ( *x* , *ax* )


op
**
The binary operator *op* is one of the following:
addition ``+`` ,
subtraction ``-`` ,
multiplication ``*`` ,
division ``/`` , or
exponentiation ``**`` .
Note that exponentiation in c++ is special and always has the function syntax;
i.e.,

| *az* = *pow* ( *ax* , *ay* )
| *az* = *pow* ( *ax* , *y* )
| *az* = *pow* ( *x* , *ay* )
| *az* = *pow_int* ( *ax* , *i* )

fun
***
This function is one of the following:
``radd`` (right addition) ,
``rsub`` (right subtraction) ,
``rmul`` (right multiplication) ,
``rdiv`` (right division).

ax
**
This object has c++ prototype

| |tab| ``const a_double&`` *ax*

ay
**
This object has c++ prototype

| |tab| ``const a_double&`` *ay*

y
*
This object has c++ prototype

| |tab| ``const double&`` *y*

x
*
This object has c++ prototype

| |tab| ``const double&`` *x*


az
**
The result has c++ prototype

| |tab| ``a_double`` *az*

pow_int
*******
Exponentiation by an integer is an even more special case.
Derivatives of the ``pow`` function will return ``nan``
when the argument value is zero; e.g. the derivative of
:math:`\R{pow} (x, 2)` at :math:`x = 0`
( derivatives of the ``pow`` function work fine when :math:`x \ne 0` ).
This is because the derivative of the log function at zero
results in a division by zero.
This ``nan`` can be avoided by using multiplication, instead of logs,
to compute powers when the exponent is an integer.

i
=
The argument to the ``pow_int`` function has c++ prototype

| |tab| ``const int&`` *i*


Example
*******
{xrst_toc_list
   example/python/core/a_double_binary_xam.py
   example/cplusplus/a_double_binary_xam.cpp
}

{xrst_end a_double_binary}
