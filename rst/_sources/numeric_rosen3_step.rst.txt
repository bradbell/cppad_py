lines 106-243 of file: example/python/numeric/rosen3_step.py

# {xrst_begin numeric_rosen3_step}
# {xrst_spell
#     rosenbrock
#     shampine
#     truncation
#     yf
#     yi
#     yp
# }
# {xrst_comment_ch #}
#
#
# One Third Order Rosenbrock ODE Step
# ###################################
#
# Syntax
# ******
#
# | *yf* =  ``rosen3_step`` ( *fun* , *ti* , *yi* , *h* )
# | *ok* =  ``check_rosen3_step`` ( *fun* , *ti* , *yi* , *h* )
#
# Purpose
# *******
# The routine ``rosen3_step`` can be used with
# ``ad_double`` to solve an initial value ODE
#
# .. math::
#
#    y^{(1)} (t)  = f( t , y )
#
# Reference
# *********
# The formulas in this method are taken from page 100 of the following
# reference (except that 98/108 was correct to 97/108):
# Shampine, L.F.,
# *Implementation of Rosenbrock Methods* ,
# ACM Transactions on Mathematical Software, Vol. 8, No. 2, June 1982.
#
# fun
# ***
# This is a function that evaluates the ordinary differential equation,
# and its partial derivatives,
#
# t
# =
# The argument *t* below is the current time.
# It can be a ``float`` or ``a_double`` .
#
# y
# =
# The argument *y* below is the current value of :math:`y(t)`.
# The type of the elements of *y*
# can be ``float`` or ``ad_double`` .
#
# f
# =
# The syntax
#
# | |tab| *yp* = *fun*\ ``.f`` ( *t* , *y* )
#
# sets *yp* to the value of :math:`f(t, y)`.
#
# f_t
# ===
# The syntax
#
# | |tab| *yp_t* = *fun*\ ``.f_t`` ( *t* , *y* )
#
# set *yp_t* to the value of :math:`\partial_t f(t, y)`.
#
# f_y
# ===
# The syntax
#
# | |tab| *yp_y* = *fun*\ ``.f_y`` ( *t* , *y* )
#
# sets *yp_y* to the value of :math:`\partial_y f(t, y)`.
#
# ti
# **
# This is the initial time for the Rosenbrock step.
# It can have type ``float`` or ``a_double`` .
# (For ``check_rosen3_step`` only ``float`` is allowed.)
#
# yi
# **
# This is the numpy vector containing the
# value of :math:`y(t)` at the initial time.
# The type of its elements can be ``float`` or ``a_double`` .
# (For ``check_rosen3_step`` only ``float`` is allowed.)
#
# h
# *
# This is the step size in time; i.e., the time at the end of the step
# minus the initial time.
# It can have type ``float`` or ``a_double`` .
# (This is not used by ``check_rosen3_step`` .)
#
# yf
# **
# This is the approximate solution for :math:`y(t)` at the final time
# as a numpy vector.
# This solution is 3-th order accurate in time :math:`t`; e.g., if
# :math:`y(t)` is a polynomial in :math:`t` of order three or lower,
# the solution has no truncation error, only round off error.
#
# ok
# **
# This is true if the function *fun*\ ``.f`` *t* , *y* )
# and the partials *fun*\ ``.f_t`` ( *t* , *y* ) ,
# *fun*\ ``.f_y`` ( *t* , *y* ) agree.
# Otherwise AD has detected an error in these functions.
#
# {xrst_toc_hidden
#  example/python/numeric/rosen3_step_xam.py
# }
# Example
# *******
# :ref:`numeric_rosen3_step_xam_py-name`
#
# Source Code
# ***********
#
# rosen3_step
# ===========
# {xrst_literal
#  # BEGIN_ROSEN3_STEP
#  # END_ROSEN3_STEP
# }
#
# check_rosen3_step
# =================
# {xrst_literal
#  # BEGIN_CHECK_ROSEN3_STEP
#  # END_CHECK_ROSEN3_STEP
# }
#
# {xrst_end numeric_rosen3_step}
